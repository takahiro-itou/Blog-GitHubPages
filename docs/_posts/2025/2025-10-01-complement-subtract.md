---
layout: math
title: "補数と引き算"
date: 2025-10-01
---

#  本記事の目的

この記事では、コンピュータで負の数を表現する方法の一つである
補数表現について解説する。
また、補数を用いた足し算で引き算を実現する方法について解説する。

#  導入

##   十進数での例

まずは馴染み深い十進数で考えることにする。

- 普通の十進数の電卓があるとする。
- 桁数が多いと面倒なので、４桁の電卓とする。
- 通常の電卓はオーバーフロー（桁あふれ）が発生すると、エラーになるが、
  あふれた上位桁（１万の位）は無視して、下位４桁が残る電卓だとする。

例えば $$ 6532 + 7644 $$ は

$$
\begin{array}{r}
6532 \\[-3pt]
\underline{+ \phantom{0}7644} \\[-2pt]
(1) 4176
\end{array}
$$

であるから、頭の (1) は無視して $$ 6532 + 7644 = 4176 $$ となる。

ところで、この電卓は、足し算はできるが引き算ができない、とする。
その状況で何とか引き算を行う方法を考えてみよう。

例として $$ 6532 - 2356 = 4176 $$ をやってみる。
この電卓では１万の位は無視しているから、
数式に１万を足したり引いたりしても結果が変わらないことに気が付けば、

$$
\begin{array}{r}
6532 \\[-3pt]
\underline{- \phantom{0}2356}
\end{array}
$$

は

$$
\begin{array}{r}
6532 \\[-3pt]
+ \phantom{0}10000 \\[-3pt]
\underline{- \phantom{01}2356}
\end{array}
$$

を計算すれば良い事が分かる。
ここで $$ 10000 - 2356 = 7644 $$ である。
（引き算ができないのにこの計算をどうするのかという問題が残るが、
一旦それは横に置いておいて）
先ほどの足し算の例で見たように、上記の計算は

$$
\begin{array}{r}
6532 \\[-3pt]
\underline{+ \phantom{0}7644} \\[-2pt]
4176
\end{array}
$$

となって、確かに $$ 6532 - 2356 = 4176 $$ という計算結果が得られる。

さらに少し工夫して $$ 10000 = 9999 + 1 $$ と分解しておき、
計算の順序を入れ替えることで
$$+ 10000 - 2356 = + 9999 - 2356 + 1 $$ と変形できるから、


$$
\begin{array}{r}
6532 \\[-3pt]
+ \phantom{0}9999 \\[-3pt]
- \phantom{0}2356 \\[-3pt]
\underline{+ \phantom{0000}1}
\end{array}
$$

となる。
やはり引き算が残っているように見えるが、
先ほどまでの引き算と根本的に違うのは、
引かれる数の全ての位が最大の９になっている。
この引き算では繰り下がりが決して発生しない。
つまり、それぞれの位ごとに引き算ができればよい。

[以前の記事]({{ site.baseurl }}{% post_url 2024/2024-04-16-bitwise-operators %})
で、ビット演算 (Bitwise Operators)  を解説しているので、
そちらも読んでおいてほしいが、
各ビット（各位）毎に演算を適用するというのは、
繰り上がりや繰り下がりで他の位の計算結果に依存する演算に比べてコストが低い。

それでも９から引くという計算が残っているがこれは、単純に各位毎に
$$  0 \leftrightarrow 9, 1 \leftrightarrow 8, \ldots, $$
というような変換を行うだけで良いから、演算コストはそれほど高くない。

今は十進数で説明しているため、ここで９から引くという引き算が入っているように見えるが、
実際にはコンピュータの世界では二進数が基本であり、
その場合は、$$ 1 - x $$ という計算は、
$$ x $$ の 0 と 1 を入れ替えるといる演算に他ならない。

つまり $$ 0b1111 - x = ~ x $$ (not x)
または $$ 0b1111 - x = 0xb1111 ^ x$$ (x と 11...1 と数値の xor)
で計算できるので、引き算をすることなく、補数を求めることができる。